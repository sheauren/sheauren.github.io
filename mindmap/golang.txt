Go lang
    Feature
        goroute
            go - go func
            channel - pine communcation
                var pipe chan int
                pipe := cmake(chan int,3)
                close
        auto garbage collection
        defer - execute when end
        := define
        make - create object
            b:=make(chan int,1)
        <- write
        -> read
        panic/recover
            err:=errors.New("error")
            panic(err)
            defer func(){ if err:=recover();err!=nil{...}}()
        closure
            func Adder() func(int) int{
                var x int 
                return func(delta int)int{
                    x+=delta
                }
            }
    environment
        go run xxx.go
        gofmt -w xxx.go
            format go file & write back
    basic
        func add(a int,b int)int{}
            _ = add(8,9)
            return 0
            func add(a int,b int)(int,int){}        
                return 3,4
            func add(a int,b int)(c int,d int){}        
                c = 3
                d = 4
                e,_ = add(18,339)
            func add(a int,arg... int)int{}
            defer
                execute when func ending
                release resource
                release connection
        var str :="hello world"
            "string"
            `string`
            len("string")
        const b string = "word"
            const ( a=0\n b=0\n c=0)
        var c string = "word"
            Var ( d=0\n e=0\n f=0)
        tmp:=[]byte(str) 
            string to byte array
        var b map[string]int
            b["test"]=3
        call by value
            int
            float
            bool
            string
            struct
            []
                len(array)
        call by reference
            chan
            map
            slice
            &/* - like C/C++       
        package main
            import "main"\n import "fmt"
            import("main"\n"fmt")            
        * pointer
            var a int=5
            var p *int = &a
        if/else
        switch/case/default
            case i>0&&i<10:{}break
        for i:=0;i<10;i++{}
            for i>0{}
                for true{}
                for {}
            for i,v range "hello world"{ }
            break/continue
        goto/label
        new - create int/struct return pointer
        array
            var a [len]int
            var a [5]int{1,2,3}
            var a [...]int{1,2,3,4,5,6}
            for index, v:=range a{}
            for i:=0;i<len(a);i++){}
            var b [5][3]int
            slice
                0<=cap(a)<=len(a)
                a[0] # 0
                a[2:4] # 2,3
                a[:] # all
                a[:2] # 0,1
        map
            var a map[string]string = map[string]string{"key":"value"}
            a["acb"]="def"
            var b:make(map[string]map[string]string)
            b["key1"]=make(map[string]string)
            b["key1"]["key"]="abc"
            # no default sort

    api
        fmt
            Println            
            Printf
                %+v
                %#v
                %T
                %t
                %b
                %q
                %x
                %p
            Scanf
        time
            Time
            Sleep
            Now
                Format
                Day
                Minute
                Month
                Year

        math
            rand
        strings
            HasPrefix
            HasSuffix
            Index
            LastIndex
            Replace
            Count
            Repeat
            ToLower
            ToUpper
            Trim
            TrimSpace
            TrimLeft
            TrimRight
            Field - Split by space
            Split
            Join            
        stringconv
            Itoa
            Atoi
        sort
            Ints(int_array)
            Strings(str_array)
        sync
            Mutex
                var lock sync.Mutex
                lock.Lock()
                lock.Unlock()
            RWMutex
                var rwLock sync.RWMutex
                rwLock.RLock()
                rwLock.RUnlock()
                rwLock.Lock()
                rwLock.Unlock()